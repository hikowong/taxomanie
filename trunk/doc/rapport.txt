PhyloExplorer
=============

:Authors:

   Nicolas Auberval
   Nicolas Clairon
   Sorel Disert

//.. contents:: Sommaire
//.. sectnum::
//   :depth: 4

Documentation technique
=======================

Choix technique
---------------

Langage de programmation::

Tout le projet PhyloExplorer repose sur le langage *Python*. Ce langage a été
choisi pour sa licence (libre), sa portabilité (multiplateforme), sa robustesse,
et sa syntaxe simple et claire. La facilité avec laquel il manipule les
chaines de caractères à fait pencher la balance en sa faveur. Enfin, une
bibliothèque python sur le traitement d'arbres phylogénétiques avait déjà été
créé par l'un des auteurs : la base était déjà faite.

Serveur Web::

Apache a été envisagé mais nous voulions un serveur web simple et autonome or
le mod_python d'apache n'est pas trivial à installer et configurer. Nous nous
sommes donc tournés vers *CherryPy* qui est un "__framework HTTP orienté
objet__". Ainsi, l'installation était grandement facilité et une utilisation
standalone pouvait être envisagée (lancer le script, ouvrez votre navigateur,
pointez à l'adresse "localhost:8080", c'est prêt !).

La gestion de graphes::

Notre but étant de créer l'aborescence du NCBI à partir d'une liste de taxon,
il nous fallait une bibliothèque de gestion de graphes. Nous utilisons pour
cela *NetworkX*. Entièrement écrite en python, cette bibliothèque
multiplateforme s'installe très facilement et est relativement puissante.

Moteur de templates::

Le moteur de templates à été attribué à *Pleet*. Une bibliothèque python
écrite par l'un des auteurs permettant d'embarquer du code python dans du
HTML. Cette bibliothèque est très simple, rapide et fait bien son travail.

Gestionnaire de projet::

Nous avons utilisé **Google Code**. Ce gestionnaire de projet permet de gérer très
simplement des petits projets en mettant à disposition un système de wiki, un
gestionnaire de bugs et un gestionnaire de version (subversion).


Structure du projet
-------------------

Nous n'avons pas voulu enfermer PhyloExplorer dans une utilisation
particulière (ici le service web). C'est pourquoi PhyloExplorer est structuré
en plusieurs parties : 

- *PhyloCore* : une batterie de classes et de méthodes qui manipule les
  collections d'arbres phylogénétiques et dialogue avec la base de données du
  NCBI.
- *PhyloWeb* : comprenant un serveur web légé et autonome ainsi qu'un
  ensemble de templates.

Cette distinction dans la structure permet aux développeurs de créer d'autres
applications en se servant de la même base. Des scripts, pipelines ou encore
des applications QT peuvent être crées à moindre coût.

PhyloCore
~~~~~~~~~
PhyloCore regroupe trois classes (TaxanomyReference, TreeCollection et
PhylogeneticTree) et une bibliothèque de gestion d'arbres phylogénétiques :
`phylogelib`.

.Diagramme de classes
image::phylo1.png[]

Phylogelib
^^^^^^^^^^

Phylogelib est une bibliothèque python qui permet de manipuler des arbres
phylogénétiques. Très rapide, elle se contente de manipuler des chaines de
caractères au format newick (on évite ainsi la lourde gestion de graphes).

.Fonctions principales utilisées dans PhyloExplorer
***************************************************
checkNwk(nwk)::

Renvoie vrai si la chaine passée en paramètre est au format newick.

getBrothers(tree, node)::

Retourne la liste des frères du noeud.

getChildren(tree)::

Retroune la liste des premiers fils de l'arbre.

getTaxa(tree)::

Renvoie la liste de tous les taxons de l'arbre.

removeBootStraps(tree)::

Supprime les "bootstraps" de l'abres

removeNexusComments(nex)::

Supprime les commentaires d'une collection au format nexus

tidyNwk(nwk)::

Nettoie la chaine au format newick en supprimant tous les espaces superflux.
******************************************************


L'outil preproc.py
^^^^^^^^^^^^^^^^^^

PhyloExplorer utilise la base de données du NCBI comme base d'information.
Cette base de données est accessible à l'adresse :
`ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz`. Cette archive
comprend plusieurs images de la base du NCBI. Celles qui nous intéressent sont
`names.dump` et `nodes.dump`. Ces images nous permettent de récupérer :

- l'id
- le nom (scientifique)
- le nom du parent
- l'homonym auquel il se rapporte
- la liste de ses parents
- la liste de ses synonymes
- la liste de ses noms communs.

Le problème réside dans le fait que toutes ces informations sont éparpillés
entre `names.dump` et `nodes.dump` (qui contiennent également beaucoup
d'informations qui ne nous sont pas utiles). Nous avons alors effectué une
compilation de ces informations et les avons placés dans le fichier
`taxonomy.csv`. Voici sa structure :

-------------------------------------------------------------------------------------------
id|nom|nom_du_parent|homonyme|liste!des!parents|liste!des!synonymes|liste!des!noms!communs|
-------------------------------------------------------------------------------------------

Les éléments d'une liste sont séparés par un point d'exclamation. l'id est
très important car il correspond à l'id du NCBI et donc de pouvoir générer les
liens pointant vers le site du NCBI.

Ainsi, à chaque fois qu'il que l'on veut mettre à jour le fichier
`taxonomy.csv`, il faudra effectuer cette procédure. Nous avons créer un
outil qui l'effectue automatiquement. Il s'appelle `preproc.py`.

Cet outil téléchargera automatiquement l'image de la base du NCBI, extraira
les informations nécessaire et générera le fichier `taxonomy.csv`.

[NOTE]
.A propos de base de données
Dans ce projet, il nous a été demandé de s'affranchir totalement de base de
données classique (MySQL, SQLLite...) pour charger toute la taxonomy du NCBI
en RAM. Cependant, pour plus de clareté (et par habitude ?) nous continuerons
de parler de base de données du NCBI


TaxonomyReference
^^^^^^^^^^^^^^^^^

Cette classe permet d'intéragir avec la base du NCBI et plus particulièrement
avec le fichier `taxonomy.csv` qu'il prend en paramètre :

----------------------------------------------
reference = TaxonomyReference( "taxonomy.csv" )
----------------------------------------------

.Méthodes principales
***************************************************
getCommonParent(self, taxa_list)::
    retourne le premier parent commun de tous les taxons présents dans la liste

getHomonyms(self, name)::
    retourne la liste des homonymes du nom passé en paramètre.\+
    Exemple:

    >>> self.getHonomyms( "echinops" )
    ['echinops <plant>', 'echinops <mammal>']

getIntervalParents(self, name1, name2)::
    retourne la liste des parents intermédiaire entre deux taxons. \+
    Exemple:

    >>> self.getIntervalParents( "eukaryota", "eutheria" )
    ['euarchontoglires', 'glires', 'rodentia', 'sciurognathi', 'muroidea']
    >>> self.getIntervalParents( "murinae", "eutheria" )

getNCBIArborescence(self, taxa_list)::
    Cette méthode prend une liste de taxon et créer l'aborescence du NCBI en
    recherchant les parents dans la base de données.

getParents(self, name)::
    retourn la liste de tous les parents d'un taxon

isHomonym(self, name)::
    retourne vrai si le taxon est un homonyme. \+
    Exemple:

    >>> self.isHomonym( "echinops" )
    True

isValid(self, name)::
    retourne vrai si le nom du taxon est un nom scientific présent dans la
    base du NCBI

stripTaxonName(self, taxon_name)::
    Troncate le nom passé dans le but d'en extraire le nom scientifique.
    Exemple:

    >>> self.stripTaxonName( "rattus" ) -> "rattus"
    >>> self.stripTaxonName( "rattus_france" ) -> "rattus"
    >>> self.stripTaxonName( "rattus_rattus_france" ) -> "rattus_rattus"

**********************************************************

Cette classe est incluse dans toutes les classes de PhyloCore.

TreeCollection
^^^^^^^^^^^^^^

Cette classe représente une collection d'arbres phylogénétiques.
Elle prend en paramètre une collection au format _Phyllip_, _Nexus_ ou
_Nexus translate_. Elle propose des méthodes permettant de manipuler
une collection comme effectuer des filtrages et des requêtes.
Elle permet également de récupérer les statistiques de la collections.

.Méthodes principales
************************************************************
getCollection(self)::
    Retourne la collection en cours ; c'est-à-dire que si une requête à
    été lancé, elle renverra la collection filtrée. Sinon, elle renverra la
    collection initiale.

clearQuery(self)::
    Cette méthode permet de mettre à blanc la requête.
    La méthode _getCollection()_ renverra alors la collection
    initiale.

query(self, query)::
    Applique une requête à la collection. `query` doit être une expression du
    type : 
+
    {genre1} > 3 and ( {genre2} == 2 or {genre3} < 4 )
+
`genre` peut être soit le nom d'un taxon (_rattus_rattus_) soit le nom
d'une espèce (_murinae_). `genre` doit être entre accolade. Le reste de la
requête est une expression python classique (d'où l'utilisation du `==`).
En fait, les noms entre accolades seront remplacés par leur occurence dans
la collection. Nous obtienons donc une expression python classique qui
sera évaluée :

        4 > 3 and ( 1 == 2 or 3 < 4 )

displayHomonymList(self)::
    Cette méthode retourne la liste des homonymes au format HTML.
+
*Remarque* : __Cette methode doit être réécrite de manière à tenir compte du MVC__

  
displayStats(self, allparents=False)::
    Cette méthode renvoie l'abre du NCBI au format HTML. Cette arbre contient
    des données statistiques qui permet de connaitre le nombre d'occurence
    d'une espèce dans la collection.
+
*Remarque* : __Cette methode doit être réécrite de manière à tenir compte du MVC.
 Elle doit se trouver dans une template__


filter(self, taxa_list)::
    Cette méthode va supprimer certains taxons de la collection d'arbre. Elle
    est très utile pour ne travailler que sur une partie de la taxonomy sans
    être pollué par d'autres taxons.
+
Cette méthode prends en paramètre  la liste des taxons à supprimer.

getNCBITreeAsNwk(self)::
    Cette méthode renvoie l'arborescence du NCBI de la collection au format
    Newick. Elle est utilisé si l'on souhaite télécharger l'arbre modèle du
    NCBI.

getNbTrees(self, taxon)::
    Retourne le nombre d'arbre dans lesquels se trouve un taxon

initStat(self)::
    Lorsque l'on fait des requêtes, on ne travaille que sur une partie de la
    collection. Cette méthode permet de mettre à jour les statistiques.
    
stat1(self)::
    Cette méthode aussi sobrement appellé stat1 permet de connaitre le nombre
    d'arbre à n feuilles. Elle renvoie un dictionnaire qui aura comme clé le
    début de l'intervalle. Voir la section statistiques pour plus de détails.

stat2(self)::
    Cette méthode permet de connaître le nombre de taxon à n arbres. Comme
    stat1, elle renvoie un dictionnaire. Voir la section statistiques pour
    plus de détails.

**********************************************************

[python]
.Utilisation
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
from treecollection import TreeCollection

# Instanciation. On passe une collection au format Nexus en paramètre
mycollection = TreeCollection( open("mycol.tre").read() )

# Récupère la collection
print mycollection.getCollection()

# Combien d'arbres sont dans la collection
print len( mycollection.getCollection() )

# Effectue une requête afin de ne garder tous les arbres dont les murinaes
# sont supérieurs à 1
mycollection.query( "{murinae} > 1" )

# Récupère la nouvelle collection
my_new_collection = mycollection.getCollection()

# Efface la requête
mycollection.clearQuery()

# Récupère la collection originelle
mycollection.getCollection()

# Filtrage. On supprime tous les taxon "mus", "pan" et "homo" de la
# collection. Le resultat sera une chaine de caractère au format Nexus.
nexus_string = mycollection.filter( ["mus", "pan", "homo"] )
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On voit bien dans cette exemple que la méthode `query` influera sur la méthode
`getCollection` qui renverra alors qu'une partie de la collection. La méthode
`clearQuery` permet d'effacer les effets de la requête.

Statistiques
++++++++++++

NOTE: TODO

PhylogeneticTree
^^^^^^^^^^^^^^^^

Cette classe ne permet d'afficher une abre phylogenetic au format HTML. La
représentation se fait sous forme d'arborescence simple. Par soucis de
performances, cette classe est chargée uniquement lors de l'affichage d'un
arbre phylogénétique. Ainsi, toutes les opérations relatives aux arbres se
trouvent soit dans la bibliothèque Phylogelib, soit dans la classe
TreeCollection.

image::phylo2.png[]

PhyloWeb
~~~~~~~~~

Dans cette partie, nous allons parler du projet PhyloExplorer à proprement
parler ; c'est-à-dire la partie applicatif. PhyloWeb est composé de deux
grands ensemble : le serveur web PhyloExplorer.py et les templates qui lui
sont associées.

PhyloExplorer.py
^^^^^^^^^^^^^^^^
Ce fichier represente en quelque sorte le _main_ du projet. C'est ce script
qu'il faudra lancer pour exécuter le serveur web. L'application sera alors
accessible via l'adresse `http://adresse_ip:port` où `adresse_ip` et `port`
sont définis dans le fichier de configuration `phyloexplorer.conf`.

le fichier `phyloexplorer.py` est composé de la classe PhyloExplorer qui sera
utilisée par l'outil CherryPy. Cette classe possède plusieurs particularités
qui sont propres à CherryPy comme l'exposition d'une méthode.

Une méthode exposée est une méthode qui sera accessible via l'URL de
l'application. Elle est reconnaissable par son décorateur :
`@cherrypy.expose`. Chaque méthode exposée doit renvoyer une chaine de
caractère qui sera affiché tel quel à l'utilisateur. Cette chaine doit donc
être au format HTML.

Pour plus d'information concernant le serveur web, merci de consulter la
documentation de CherryPy.

Pour renvoyer du HTML, nous utilisons la méthode `self._presentation` qui
prend en paramètre, le nom de la template à utiliser, un message d'information
(facultatif) et une petite chaine de caractère qui sera placé en haut de la
page et qui indiquera où se trouve l'utilisateur (ex : `Home > Statistics`).


Les templates
^^^^^^^^^^^^^

L'utilisation des templates métite que l'on s'y attarde un petit peu. Toutes
les templates sont regroupées dans le répertoire "templates". Ce répertoire
regroupe aussi les scripts CSS et javascripts.

Une template, bien qu'ayant l'extension `.html`, est un ensemble de code
python et d'html. Le code python est placé entre les balises `<%` et `%>`.

[python]
.Une template basique
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<%
if True:
%>
    <%|%>                           <1>
    <b> Hello World ! </b>
<%
else:
    #                               <2>
%>
    <i> Hello Me ! </i>
<%|%>
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Le moteur de template Pleet va evaluer le code python et renverra le resultat.
Dans cet exemple, `True` est toujours vrai donc `Hello Word` sera toujours
affiché.  

Le symbole `<%|%>` *(1)* permet de spécifier l'indentation. On indique ainsi au
moteur de template si on se trouve toujours dans le `if` ou non.

NOTE: Le fait de placer une ligne de commentaire *(2)* spécifie également l'indentation.

Pleet permet "d'exposer" des objets afin qu'ils puissent être utilisé dans les
templates.

[python]
.Exposition d'un objet
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
pleet["_civilite_"] = civilite
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dans cet exemple, on rend accessible la variable `civilite` accessible dans la
template sous le nom `_civilite_`.

[python]
.Utilisation d'un objet exposé
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Bonjour 
<%
if _civilite_ == "Mme":
    #
%>
    Madame,
<%
elif _civilite_ == "Mlle":
    #
%>
    Mademoiselle,
<%
else:
    #
%>
    Monsieur,
<%|%>
code~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dans cet exemple, une série de tests sur la variable `_civilite_` permettra de
produire la bonne template.


Installation
------------
Cette section détaille la procédure d'installation et de configuration de
l'application web PhyloExplorer. 

Prérequis
~~~~~~~~~
Pour une utilisation optimale, PhyloExplorer nécessite au minimum 2 Go de
mémoire RAM. Prévoir également un processeur cadencé à 2 Ghz et 200 Mo d'espace
disque pour l'installation.

Installation
~~~~~~~~~~~~

Installation des dépendances
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
PhyloExplorer nécessite les bibliothèques suivantes :

- Python >= 2.4 : (`http://www.python.org`)
- CherryPy >= 3.0 (`http://www.cherrypy.org/`)
- NetworkX >= 0.35 (`https://networkx.lanl.gov/wiki`)
- Pleet (le paquet est disponible dans tools)

Chacune de ces bibliothèques s'installe très facilement : extraire l'archive
et taper simplement sous root `$ python setup install.py`.

Installation de PhyloExplorer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
NOTE: TODO

Configuration
~~~~~~~~~~~~
Le serveur web utilise le fichier `phyloexplorer.conf` pour sa configuration.
Voici sa structure :

----------------------------------------------
[global]
log.screen = 0 
server.socket_host = "127.0.0.1"
server.socket_port = 8080
server.thread_pool = 10
session.timeout = 1800
proxy = "www.info-ufr.univ-montp2.fr:3128"
----------------------------------------------

log.screen::

Cette variable est un booleen. Si elle est vrai (positionnée à 1), des
informations de débogage seront envoyés sur la sortie standard de la console.
Cette variable doit être mise à 0 pour un serveur de production.
Voir la documentation de CherryPy pour plus de détails.

server.socket_host::

Definit l'adresse ip de la machine où est lancé le serveur. 
Voir la documentation de CherryPy pour plus de détails.

server.socket_port::

Definit le port où devra être accessible l'application.
Voir la documentation de CherryPy pour plus de détails.

server.thread_pool::

Définit le nombre d'instance à déployer. Plus le nombre de connexion est
élevé, plus ce chiffre doit augmenter.
Voir la documentation de CherryPy pour plus de détails.

session.timeout::

Précise la durée de la session d'un utilisateur. Elle se définit en secondes
et indique la période d'inactivité autorisée de l'utilisateur avant
l'expiration de sa session.

proxy (facultatif)::

Cette variable est propre à PhyloExplorer (ie ne provient pas de CherryPy).
Elle permet de spécifier l'adresse du proxy afin d'autoriser l'affichage des
images et la correction du nom des taxons. Si vous avez un problème avec ces
fonctionnalités, vous devriez vérifier que cette variable est correctement
renseignée.

Annexe
======

Liens externes
--------------

*Python* : `http://www.python.org`

*NetworkX* : `https://networkx.lanl.gov/wiki`

*CherryPy* : `http://www.cherrypy.org/`


